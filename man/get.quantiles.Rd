% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_quantiles.R
\name{get.quantiles}
\alias{get.quantiles}
\title{Estimate quantiles of a normalized time series}
\usage{
get.quantiles(model.y, norm.x.df, bulk.x.df, tail.x.df, q_norm, q_bulk, q_tail,
  year.range = c(1920, 2099), lat = numeric(), lon = numeric(), bases.dir,
  norm.x = numeric(), bulk.x = numeric(), tail.x = numeric(),
  get.volc = TRUE)
}
\arguments{
\item{model.y}{the temperature time series, as either a numeric vector or an
\code{xts} object. If multiple runs are analyzed, they should be end-to-end
(so [run 1 1979-2099, run 2 1979-2099, etc...]). The number of runs is
inferred from the length of the time series and the \code{year.range}
parameter below.}

\item{norm.x.df, bulk.x.df, tail.x.df}{degrees of freedom for the basis
functions, as \code{3 x 1} vectors giving the dfs for the seasonal cycle,
long-term trend, and interaction, respectively}

\item{q_norm}{a \code{3 x 1} vector giving the quantiles used to normalize
\code{model.y}; the estimated \code{q_norm[2]} is subtracted from
\code{model.y}, and the resultant time series is divided by the IQR
\code{q_norm[3]-q_norm[1]} (i.e. \code{c(0.1,0.5,0.9)} - \code{q_norm}[2]
should \emph{probably} always be \code{0.5}, and \code{q_norm}[c(1,3)]
should \emph{probably} always be symmetric)}

\item{q_bulk}{a vector giving the non-tail quantiles to be estimated}

\item{q_tail}{a vector giving the tail quantiles to be estimated - these are
calculated with respect to the min and max of \code{q_bulk}, so if you set
\code{q_tail[1]} to \code{0.75}, that 'real' value of that quantile is
actually \code{max(q_bulk)+(1-max(q_bulk))*0.75}, and so forth.}

\item{year.range}{manual specification of the year range (as a \code{2 x 1}
vector giving the first and last year of the inputted time series. This is
to allow for a general treatment of inputted time series with multiple runs
- xts objects are ordered, which is problematic when you have 40 data
points for the same date in what should be separate time series).}

\item{lat, lon}{the latitude/longitude of the pixel. If \code{get.volc=TRUE},
\code{lat} is used to determine which base function to load. \code{lon} (and
\code{lat}, if \code{get.volc=FALSE}) is merely outputted directly into the
output list. Can be left empty.}

\item{bases.dir}{directory where the basis functions are stored. Within the
normal file structure, this would be "\code{[defaults$aux.dir],bases/}".}

\item{norm.x, bulk.x, tail.x}{directly input bases (calculated with
\code{\link{get.predictors}}) if desired. Otherwise, the code will first
attempt to load them in \code{bases.dir}, then recalculate using
\code{\link{get.predictors}} if not found. Can be left empty.}

\item{get.volc}{if loading or calculating basis functions, sets whether or
not to include the volcanic CO2 fit in the normalization basis function (by
default \code{FALSE}).}
}
\value{
A list is returned, with list members giving the fit coefficients for
  the normalization, bulk/primary, and tail fits (\code{coef_norm},
  \code{coef_bulk}, and \code{coef_tail}, respectively), in addition to the
  inputted \code{q_bulk}, \code{q_tail}, \code{q_norm}, \code{q_all} (a
  listing of all the estimated quantiles), \code{norm.x.df},
  \code{bulk.x.df}, and \code{tail.x.df}, and \code{lat}, \code{lon}, and
  \code{year.range}.
}
\description{
\code{get.quantiles} performs quantile regressions on the time series
\code{model.y} to estimate the quantiles given by \code{q_bulk} and
\code{q_tail}, after normalizing using \code{q_norm}. Specifically,
\enumerate{
   \item the quantiles \code{q_norm} are estimated on \code{model.y}
   \item \code{model.y} is normalized, by subtracting the estimated quantile
     \code{q_norm[2]} and dividing by the IQR of estimated quantiles
     \code{q_norm[3]-q_norm[1]}
   \item the quantiles \code{q_bulk} are estimated on the normalized \code{model.y}
   \item the high tail and low tail are calculated by subtracting the max and min
     estimated quantile (from 3.) from the normalized \code{model.y}
   \item the quantiles \code{q_tail} are estimated from the high tail and low tail
     exceedences (so from \code{exceedence[exceedence>0]} for the high and low)
}
}
\section{Notes on inputted quantiles to be estimated}{

\describe{
  \item{q_norm}{quantiles used for normalization. \code{model.y} is normalized by
          subtracting the estimated \code{q_norm[2]} and dividing by the
          estimated IQR \code{q_norm[3]-q_norm[1]}. We therefore suggest to keep
          \code{q_norm[2] == 0.5} (the median).}
  \item{q_bulk}{primary, non-tail quantiles to estimate (post-normalization)}
  \item{q_tail}{tail quantiles to estimate; based on exceedences of the post-
          normalized \code{model.y} beyond the max and min estimated \code{q_bulk}.
          Note that \code{q_tail} is based on the exceedence, so if you set
          \code{q_tail[1]} to \code{0.75}, that 'real' value of that quantile is actually
          \code{max(q_bulk)+(1-max(q_bulk))*0.75}, and so forth.}
 }
}

\section{Notes on estimation}{

  Quantiles are estimated using quantile regression, with cubic spline basis
  functions, with degrees of freedom set by \code{norm.x.df},
  \code{bulk.x.df}, and \code{tail.x.df}, for the normalization, bulk, and
  tail exceedence quantile calculations, respectively. The basis functions
  are either loaded (if they exist in the \code{bases.dir}, this requires
  bases to be calculated using \code{\link{get.predictors}}), calculated from
  scratch using \code{\link{get.predictors}}, or directly inputted using the
  function parameters \code{norm.x}, \code{bulk.x}, and \code{tail.x}.
  Loading pre- calculated bases is generally the fastest method.

  Each of \code{norm.x.df}, \code{bulk.x.df}, and \code{tail.x.df} is a
  \code{3 x 1} vector giving the degrees of freedom for the seasonal cycle
  (based only on the month-of-year), the long-term change (based only on the
  year), and the interaction (changing seasonal cycle, based on both
  month-of-year and year), respectively.
}

